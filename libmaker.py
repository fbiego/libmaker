'''
   MIT License

  Copyright (c) 2024 Felix Biego

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  ______________  _____
  ___  __/___  /_ ___(_)_____ _______ _______
  __  /_  __  __ \__  / _  _ \__  __ `/_  __ \
  _  __/  _  /_/ /_  /  /  __/_  /_/ / / /_/ /
  /_/     /_.___/ /_/   \___/ _\__, /  \____/
							  /____/

'''


import os
import argparse
import re
import json


info = ''' Generating library folder structure
>python libmaker.py {name} [--arduino] [--src]
'''

header = '''
// ---------------------------------------------
// This file was generated by libmaker.py
// Project: {{Name}}
// ---------------------------------------------
'''


cpp_content = '''
#include "{{Name}}.h"

/*!
	@brief  Constructor for {{Name}}
*/
{{Name}}::{{Name}}(){
    
}

/*!
	@brief  Destructor for {{Name}}
*/
{{Name}}::~{{Name}}(){
    
}

/*!
	@brief  test
*/
void {{Name}}::test(){
    //
}

/*!
	@brief  begin
*/
void {{Name}}::begin(){
    // sample begin function, (not necessary)
    test();
}

/*!
	@brief  update
*/
void {{Name}}::update(){
    // sample update function, (not necessary)
}

'''

h_content = '''
#ifndef {{NAME}}_H
#define {{NAME}}_H

{{arduino_include}}
class {{Name}} {
    public:
        // accessible from outside the class
        {{Name}}(); // constructor
        ~{{Name}}(); // destructor
        
        void begin();
        void update();
        
    protected:
        // cannot be accessed from outside the class, however, they can be accessed in inherited classes
    private:
        // cannot be accessed (or viewed) from outside the class
        void test();
};

#endif
'''

keywords = '''{{Name}}  KEYWORD1

test    KEYWORD2
begin    KEYWORD2
update    KEYWORD2
'''

properties = '''name={{Name}}
version=1.0.0
author=author
maintainer=author
sentence=Short info about your library
paragraph=Explain your library
category=General
url=https://github.com/your_library_repo
architectures=*
includes={{Name}}.h
'''

example = '''
#include <{{Name}}.h>

{{Name}} {{name}};

void setup() {
  // put your setup code here, to run once:
  {{name}}.begin();
}

void loop() {
  // put your main code here, to run repeatedly:
  {{name}}.update();
}
'''

platformio = '''
; PlatformIO Project Configuration File
;
;   Build options: build flags, source filter
;   Upload options: custom upload port, speed and extra flags
;   Library options: dependencies, extra library storages
;   Advanced options: extra scripting
;
; Please visit documentation for the other options and examples
; https://docs.platformio.org/page/projectconf.html


[platformio]

; Uncomment only one example to test
src_dir = examples/{{name}}
; src_dir = examples/sample2


[env:test]
; 
platform = espressif32
framework = arduino
board = esp32dev

lib_deps = 
	; use src folder as library
	file://./src
	; external library dependencies below

'''


def is_valid_name(name):
    # Use regular expression to check if the name is valid
    pattern = re.compile(r'^[a-zA-Z][a-zA-Z0-9_]*$')
    return bool(pattern.match(name))

def create_lib(name, arduino=False, src=False, pio=False):
    # Create folder
    folder_path = os.path.join(os.getcwd(), name)
    os.makedirs(folder_path, exist_ok=True)
    
    code_path = folder_path
    if src or pio:
        code_path = os.path.join(os.getcwd(), f"{name}/src/")
        os.makedirs(code_path, exist_ok=True)

    # Create and write to h file
    header_file_path = os.path.join(code_path, f"{name}.h")
    
    include = ""
    if arduino or pio:
        include = "#include <Arduino.h>\n"
    with open(header_file_path, 'w') as header_file:
        header_file.write(header.replace("{{Name}}", name))
        header_file.write(h_content.replace("{{Name}}", name).replace("{{NAME}}", name.upper()).replace("{{arduino_include}}", include))

    # Create and write to cpp file
    cpp_file_path = os.path.join(code_path, f"{name}.cpp")
    with open(cpp_file_path, 'w') as cpp_file:
        cpp_file.write(header.replace("{{Name}}", name))
        cpp_file.write(cpp_content.replace("{{Name}}", name))
    
    if arduino or pio:
        # Create and write to keywords file
        keywords_file_path = os.path.join(folder_path, f"keywords.txt")
        with open(keywords_file_path, 'w') as keywords_file:
            keywords_file.write(keywords.replace("{{Name}}", name))
        
        # Create and write to properties file
        properties_file_path = os.path.join(folder_path, f"library.properties")
        with open(properties_file_path, 'w') as properties_file:
            properties_file.write(properties.replace("{{Name}}", name))
            
        json_data = {}
        json_data['name'] = name
        json_data['version '] = "1.0.0"
        json_data['keywords'] = "Arduino, Library"
        json_data['description'] = "Your library description"

        repo = {}
        repo['type'] = "git"
        repo['url'] = "repo_url"
        json_data['repository'] = repo

        author1 = {}
        author1['name'] = "author"
        author1['email'] = "author_email"
        author1['maintainer'] = True
        json_data['authors'] = [author1]

        json_data['frameworks'] = "arduino"
        json_data['platforms'] = ""
        
        # Create and write to json file
        json_file_path = os.path.join(folder_path, f"library.json")
        with open(json_file_path, 'w') as json_file:
            json.dump(json_data, json_file, indent=4)
        
        example_path = os.path.join(os.getcwd(), f"{name}/examples/{name.lower()}/")
        os.makedirs(example_path, exist_ok=True)
        # Create and write to example file
        example_file_path = os.path.join(example_path, f"{name.lower()}.ino")
        with open(example_file_path, 'w') as example_file:
            example_file.write(example.replace("{{Name}}", name).replace("{{name}}", name.lower()))
    if pio:
        pio_file_path = os.path.join(folder_path, f"platformio.ini")
        with open(pio_file_path, 'w') as pio_file:
            pio_file.write(platformio.replace("{{name}}", name.lower()))

    print(f"{name} library structure created.")
    print("------------- Success -------------")
    
def caps(word):
    # Check if the word is not empty
    if word:
        # Capitalize the first letter and concatenate with the rest of the word
        return word[0].upper() + word[1:]

def main():
    parser = argparse.ArgumentParser(description='Create a library with specified name.')
    parser.add_argument('name', type=str, help='Name for the library')
    parser.add_argument('--arduino', action='store_true', help='Include Arduino support')
    parser.add_argument('--src', action='store_true', help='use src folder')
    parser.add_argument('--pio', action='store_true', help='add platformio support for testing & development')

    args = parser.parse_args()
    
    if is_valid_name(args.name):
        print(f"Generating structure and files for {caps(args.name)}")
        create_lib(caps(args.name), arduino=args.arduino, src=args.src, pio=args.pio)
    else:
        print(f"The name '{args.name}' is not valid. Please start with a letter and use only letters, numbers, and underscores.")

if __name__ == "__main__":
    main()
